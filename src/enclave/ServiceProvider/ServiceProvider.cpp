#include <openssl/pem.h>
#include <cassert>
#include <fstream>
#include <iomanip>
#include <sgx_tcrypto.h>

#include "ecp.h"
#include "ias_ra.h"
#include "iasrequest.h"
#include "crypto.h"
#include "base64.h"
#include "json.hpp"

#include "ServiceProvider.h"

// Your 16-byte Service Provider ID (SPID), assigned by Intel.
const uint8_t spid[] = {0xA4,0x62,0x09,0x2E,0x1B,0x59,0x26,0xDF,0x44,0x69,0xD5,0x61,0xE2,0x54,0xB0,0x1E};

// The EPID security policy you chose (linkable -> true, unlinkable -> false).
const bool linkable_signature = false;

ServiceProvider service_provider(
  std::string(reinterpret_cast<const char *>(spid), sizeof(spid)),
  linkable_signature,
  // Whether to use the production IAS URL rather than the testing URL.
  false);

void lc_check(lc_status_t ret) {
  if (ret != LC_SUCCESS) {
    std::string error;
    switch (ret) {
    case LC_ERROR_UNEXPECTED:
      error = "Unexpected error";
      break;
    case LC_ERROR_INVALID_PARAMETER:
      error = "Invalid parameter";
      break;
    case LC_ERROR_OUT_OF_MEMORY:
      error = "Out of memory";
      break;
    default:
      error = "Unknown error";
    }

    throw std::runtime_error(
      std::string("Service provider crypto failure: ")
      + error);
  }
}


void ServiceProvider::load_private_key(const std::string &filename) {
  FILE *private_key_file = fopen(filename.c_str(), "r");
  if (private_key_file == nullptr) {
    throw std::runtime_error(
      std::string("Error: Private key file '")
      + filename
      + std::string("' does not exist. Set $PRIVATE_KEY_PATH to the file generated by "
                    "openssl ecparam -genkey, probably called ${OPAQUE_HOME}/private_key.pem."));
  }

  EVP_PKEY *pkey = PEM_read_PrivateKey(private_key_file, NULL, NULL, NULL);
  if (pkey == nullptr) {
    throw std::runtime_error(
      "Unable to read private key from '"
      + filename
      + std::string("'."));
  }

  EC_KEY *ec_key = EVP_PKEY_get1_EC_KEY(pkey);
  if (!ec_key) {
    throw std::runtime_error("EVP_PKEY_get1_EC_KEY failed.");
  }

  const EC_GROUP *group = EC_KEY_get0_group(ec_key);
  const EC_POINT *point = EC_KEY_get0_public_key(ec_key);

  BIGNUM *x_ec = BN_new();
  BIGNUM *y_ec = BN_new();
  if (EC_POINT_get_affine_coordinates_GFp(group, point, x_ec, y_ec, nullptr) == 0) {
    throw std::runtime_error("EC_POINT_get_affine_coordinates_GFp failed.");
  }

  const BIGNUM *priv_bn = EC_KEY_get0_private_key(ec_key);

  // Store the public and private keys in binary format
  std::unique_ptr<uint8_t> x_(new uint8_t[LC_ECP256_KEY_SIZE]);
  std::unique_ptr<uint8_t> y_(new uint8_t[LC_ECP256_KEY_SIZE]);
  std::unique_ptr<uint8_t> r_(new uint8_t[LC_ECP256_KEY_SIZE]);

  std::unique_ptr<uint8_t> x(new uint8_t[LC_ECP256_KEY_SIZE]);
  std::unique_ptr<uint8_t> y(new uint8_t[LC_ECP256_KEY_SIZE]);
  std::unique_ptr<uint8_t> r(new uint8_t[LC_ECP256_KEY_SIZE]);

  BN_bn2bin(x_ec, x_.get());
  BN_bn2bin(y_ec, y_.get());
  BN_bn2bin(priv_bn, r_.get());

  // reverse x_, y_, r_
  for (uint32_t i = 0; i < LC_ECP256_KEY_SIZE; i++) {
    x.get()[i] = x_.get()[LC_ECP256_KEY_SIZE-i-1];
    y.get()[i] = y_.get()[LC_ECP256_KEY_SIZE-i-1];
    r.get()[i] = r_.get()[LC_ECP256_KEY_SIZE-i-1];
  }

  // Store public and private keys
  memcpy(sp_pub_key.gx, x.get(), LC_ECP256_KEY_SIZE);
  memcpy(sp_pub_key.gy, y.get(), LC_ECP256_KEY_SIZE);
  memcpy(sp_priv_key.r, r.get(), LC_ECP256_KEY_SIZE);

  // Clean up
  BN_free(x_ec);
  BN_free(y_ec);
  EC_KEY_free(ec_key);
  EVP_PKEY_free(pkey);
}

void ServiceProvider::set_shared_key(const uint8_t *shared_key) {
  memcpy(this->shared_key, shared_key, LC_AESGCM_KEY_SIZE);
}

void ServiceProvider::export_public_key_code(const std::string &filename) {
  std::ofstream file(filename.c_str());

  file << "#include \"key.h\"\n";
  file << "const sgx_ec256_public_t g_sp_pub_key = {\n";

  file << "{";
  for (uint32_t i = 0; i < LC_ECP256_KEY_SIZE; ++i) {
    file << "0x" << std::hex << std::setfill('0') << std::setw(4) << int(sp_pub_key.gx[i]);
    if (i < LC_ECP256_KEY_SIZE - 1) {
      file << ", ";
    }
  }
  file << "},\n";

  file << "{";
  for (uint32_t i = 0; i < LC_ECP256_KEY_SIZE; ++i) {
    file << "0x" << std::hex << std::setfill('0') << std::setw(4) << int(sp_pub_key.gy[i]);
    if (i < LC_ECP256_KEY_SIZE - 1) {
      file << ", ";
    }
  }
  file << "}\n";

  file << "};\n";
  file.close();
}

void ServiceProvider::connect_to_ias(const std::string &ias_report_signing_ca_file) {
  try {
    connect_to_ias_helper(ias_report_signing_ca_file);
  } catch (const std::runtime_error &e) {
    if (require_attestation) {
      throw;
    }
  }
}

void ServiceProvider::connect_to_ias_helper(const std::string &ias_report_signing_ca_file) {
  if (this->ias) {
    return;
  }

  std::unique_ptr<IAS_Connection> ias(
    new IAS_Connection(is_production ? IAS_SERVER_PRODUCTION : IAS_SERVER_DEVELOPMENT, 0));

  const char *ias_client_cert_file = std::getenv("IAS_CLIENT_CERT_FILE");
  if (!ias_client_cert_file) {
    throw std::runtime_error(
      "Set $IAS_CLIENT_CERT_FILE to the file generated by openssl x509, probably called "
      "${OPAQUE_HOME}/client.crt.");
  }
  ias->client_cert(ias_client_cert_file, "PEM");

  const char *ias_client_cert_key_password_file = std::getenv("IAS_CLIENT_CERT_KEY_PASSWORD_FILE");
  std::string password;
  if (ias_client_cert_key_password_file) {
    std::ifstream f(ias_client_cert_key_password_file);
    std::stringstream s;
    s << f.rdbuf();
    password = s.str();
  }
  const char *ias_client_key_file = std::getenv("IAS_CLIENT_KEY_FILE");
  if (!ias_client_key_file) {
    throw std::runtime_error(
      "Set $IAS_CLIENT_KEY_FILE to the file generated by openssl genrsa, probably called "
      "${OPAQUE_HOME}/client.key.");
  }
  ias->client_key(ias_client_key_file, password.empty() ? nullptr : password.c_str());

  ias->proxy_mode(IAS_PROXY_NONE);

  ias->agent("wget");

  X509 *signing_ca;
  if (!cert_load_file(&signing_ca, ias_report_signing_ca_file.c_str())) {
    throw std::runtime_error(std::string("Could not load ") + ias_report_signing_ca_file);
  }
  X509_STORE *store = cert_init_ca(signing_ca);
  if (!store) {
    throw std::runtime_error("Could not initialize certificate store.");
  }
  ias->cert_store(store);

  ias->ca_bundle("/etc/ssl/certs/ca-certificates.crt");

  // Save the created IAS_Connection. We do this last so that any initialization errors do not
  // result in corrupt state, and a future call to this method will start from scratch.
  this->ias = std::move(ias);
}

void ServiceProvider::process_msg0(uint32_t extended_epid_group_id) {
  // From Intel's guide:
  // "The Intel Attestation Service only supports the value of zero for the extended GID."
  if (extended_epid_group_id != 0) {
    throw std::runtime_error(
      std::string("Unsupported extended EPID group ")
      + std::to_string(extended_epid_group_id));
  }
}

std::unique_ptr<sgx_ra_msg2_t> ServiceProvider::process_msg1(
  sgx_ra_msg1_t *msg1, uint32_t *msg2_size) {
  // The following procedure follows Intel's guide:
  // https://software.intel.com/en-us/articles/code-sample-intel-software-guard-extensions-remote-attestation-end-to-end-example
  // The quotes below are from this guide.

  // "Generate a random EC key using the P-256 curve. This key will become Gb."
  lc_ec256_private_t priv_key;
  lc_ec256_public_t pub_key;
  lc_check(lc_ecc256_create_key_pair(&priv_key, &pub_key));

  // Save the group ID, the client's public ECCDH key, and the generated keypair for future steps.
  memcpy(sp_db.gid, msg1->gid, sizeof(sgx_epid_group_id_t));
  sp_db.g_a = msg1->g_a;
  sp_db.g_b = pub_key;
  sp_db.b = priv_key;

  // "Derive the key derivation key (KDK) from Ga and Gb"
  lc_ec256_dh_shared_t dh_key;
  lc_check(lc_ecc256_compute_shared_dhkey(&priv_key, &msg1->g_a, &dh_key));

  // "Derive the SMK from the KDK by performing an AES-128 CMAC on the byte sequence:
  // 0x01 || SMK || 0x00 || 0x80 || 0x00
  // using the KDK as the key. Note that || denotes concatenation and “SMK” is a literal string
  // (without quotes)."
  derive_key(&dh_key, SAMPLE_DERIVE_KEY_SMK, &sp_db.smk_key);
  // We also precompute the same result with different strings for future messages.
  derive_key(&dh_key, SAMPLE_DERIVE_KEY_MK, &sp_db.mk_key);
  derive_key(&dh_key, SAMPLE_DERIVE_KEY_SK, &sp_db.sk_key);
  derive_key(&dh_key, SAMPLE_DERIVE_KEY_VK, &sp_db.vk_key);

  // "Query IAS to obtain the SigRL for the client's Intel EPID GID."
  string sig_rl;
  uint32_t gid;
  memcpy(reinterpret_cast<uint8_t *>(&gid), &msg1->gid, sizeof(sgx_epid_group_id_t));
  try {
    if (!ias) {
      throw std::runtime_error("process_msg1 called before ensure_ias_connection");
    }
    IAS_Request req(ias.get(), ias_api_version);
    ias_check(req.sigrl(gid, sig_rl));
  } catch (const std::runtime_error &e) {
    if (require_attestation) {
      throw;
    }
  }

  // Allocate msg2 with enough space for the SigRL, which is a flexible array member at the end
  *msg2_size = sizeof(sgx_ra_msg2_t) + sig_rl.length();
  std::unique_ptr<sgx_ra_msg2_t> msg2(reinterpret_cast<sgx_ra_msg2_t *>(new uint8_t[*msg2_size]));

  // Construct msg2
  msg2->g_b = sp_db.g_b;
  memcpy_s(&msg2->spid, sizeof(sgx_spid_t), spid.c_str(), spid.size());
  // "Determine the quote type that should be requested from the client (0x0 for unlinkable, and 0x1
  // for linkable). Note that this is a service provider policy decision, and the SPID must be
  // associated with the correct quote type."
  msg2->quote_type =
    linkable_signature ? SAMPLE_QUOTE_LINKABLE_SIGNATURE : SAMPLE_QUOTE_UNLINKABLE_SIGNATURE;
  // "Set the KDF_ID. Normally this is 0x1."
  msg2->kdf_id = 0x1;

  // "Calculate the ECDSA signature of:
  // Gbx || Gby || Gax || Gay
  // (traditionally written as r || s) with the service provider's EC private key."
  lc_ec256_public_t gb_ga[2];
  gb_ga[0] = sp_db.g_b;
  gb_ga[1] = sp_db.g_a;
  lc_check(lc_ecdsa_sign(reinterpret_cast<const uint8_t *>(&gb_ga), sizeof(gb_ga),
                         &sp_priv_key,
                         &msg2->sign_gb_ga));

  // "Calculate the AES-128 CMAC of:
  // Gb || SPID || Quote_Type || KDF_ID || SigSP
  // using the SMK as the key."
  uint8_t mac[SGX_CMAC_MAC_SIZE] = {0};
  uint32_t cmac_size = offsetof(sgx_ra_msg2_t, mac);
  lc_check(lc_rijndael128_cmac_msg(&sp_db.smk_key,
                                   reinterpret_cast<const uint8_t *>(&msg2->g_b),
                                   cmac_size,
                                   &mac));
  memcpy(&msg2->mac, &mac, sizeof(sgx_mac_t));

  msg2->sig_rl_size = sig_rl.size();
  memcpy(&msg2->sig_rl, sig_rl.c_str(), sig_rl.size());

  return msg2;
}

std::unique_ptr<ra_msg4_t> ServiceProvider::process_msg3(
  sgx_ra_msg3_t *msg3, uint32_t msg3_size, uint32_t *msg4_size) {
  if (msg3_size < sizeof(sgx_ra_msg3_t)) {
    throw std::runtime_error("process_msg3: msg3 is invalid (expected sgx_ra_msg3_t).");
  }

  // The following procedure follows Intel's guide:
  // https://software.intel.com/en-us/articles/code-sample-intel-software-guard-extensions-remote-attestation-end-to-end-example
  // The quotes below are from this guide.

  // "Verify that Ga in msg3 matches Ga in msg1."
  if (memcmp(&sp_db.g_a, &msg3->g_a, sizeof(lc_ec256_public_t))) {
    throw std::runtime_error("process_msg3: g_a mismatch.");
  }

  // "Verify CMAC_SMK(M)."
  uint32_t mac_size = msg3_size - sizeof(sgx_mac_t);
  const uint8_t *msg3_cmaced = reinterpret_cast<const uint8_t*>(msg3) + sizeof(sgx_mac_t);
  lc_cmac_128bit_tag_t mac;
  lc_check(lc_rijndael128_cmac_msg(&sp_db.smk_key, msg3_cmaced, mac_size, &mac));
  if (memcmp(&msg3->mac, mac, sizeof(mac))) {
    throw std::runtime_error("process_msg3: MAC mismatch.");
  }

  // "Extract the quote from msg3."
  sample_quote_t *quote = reinterpret_cast<sample_quote_t *>(msg3->quote);
  // Use the fact that msg3.quote is a flexible array to calculate the quote size
  uint32_t quote_size = msg3_size - sizeof(sgx_ra_msg3_t);

  // "Verify that the first 32-bytes of the report data match the SHA-256 digest of
  // (Ga || Gb || VK), where || denotes concatenation. VK is derived by performing an AES-128 CMAC
  // over the following byte sequence, using the KDK as the key:
  // 0x01 || "VK" || 0x00 || 0x80 || 0x00
  lc_sha_state_handle_t sha_handle;
  lc_sha256_init(&sha_handle);
  lc_sha256_update(reinterpret_cast<const uint8_t *>(&sp_db.g_a), sizeof(sp_db.g_a), sha_handle);
  lc_sha256_update(reinterpret_cast<const uint8_t *>(&sp_db.g_b), sizeof(sp_db.g_b), sha_handle);
  lc_sha256_update(reinterpret_cast<const uint8_t *>(&sp_db.vk_key), sizeof(sp_db.vk_key), sha_handle);
  lc_sha256_hash_t hash;
  lc_sha256_get_hash(sha_handle, &hash);
  lc_sha256_close(sha_handle);
  if (memcmp(reinterpret_cast<const uint8_t *>(&hash),
             reinterpret_cast<const uint8_t *>(&quote->report_body.report_data),
             LC_SHA256_HASH_SIZE)) {
    throw std::runtime_error("process_msg3: Report data digest mismatch.");
  }

  // Verify that the EPID group ID in the quote matches the one from msg1
  if (memcmp(sp_db.gid, quote->epid_group_id, sizeof(sgx_epid_group_id_t))) {
    throw std::runtime_error("process_msg3: EPID GID mismatch");
  }

  // Encode the quote as base64
  std::string quote_base64(base64_encode(reinterpret_cast<char *>(quote), quote_size));

  // "Submit the quote to IAS, calling the API function to verify attestation evidence."
  std::string content;
  try {
    if (!ias) {
      throw std::runtime_error("process_msg3 called before ensure_ias_connection");
    }
    IAS_Request req(ias.get(), ias_api_version);

    std::map<std::string, std::string> payload;
    payload.insert(std::make_pair("isvEnclaveQuote", quote_base64));

    std::vector<std::string> messages;
    ias_check(req.report(payload, content, messages));
  } catch (const std::runtime_error &e) {
    if (require_attestation) {
      throw;
    }
  }

  if (!content.empty()) {
    json::JSON reportObj = json::JSON::Load(content);

    if (!reportObj.hasKey("version")) {
      throw std::runtime_error("IAS: Report is missing an API version.");
    }

    unsigned int rversion = (unsigned int)reportObj["version"].ToInt();
    if (rversion != ias_api_version) {
      throw std::runtime_error(
        std::string("IAS: Report version ")
        + std::to_string(rversion)
        + std::string(" does not match API version ")
        + std::to_string(ias_api_version));
    }

    // "Extract the attestation status for the enclave.
    // Decide whether or not to trust the enclave."
    if (reportObj["isvEnclaveQuoteStatus"].ToString().compare("OK") == 0) {
      // Enclave is trusted
    } else if (reportObj["isvEnclaveQuoteStatus"].ToString().compare("CONFIGURATION_NEEDED") == 0) {
      throw std::runtime_error(
        "Enclave not trusted. IAS reports CONFIGURATION_NEEDED. Check the BIOS.");
    } else if (reportObj["isvEnclaveQuoteStatus"].ToString().compare("GROUP_OUT_OF_DATE") != 0) {
      throw std::runtime_error(
        "Enclave not trusted. IAS reports GROUP_OUT_OF_DATE. Update the BIOS.");
    } else {
      if (require_attestation) {
        throw std::runtime_error("Enclave not trusted.");
      }
    }
  }

  // Generate msg4, containing the shared secret to be sent to the enclave.
  *msg4_size = sizeof(ra_msg4_t);
  std::unique_ptr<ra_msg4_t> msg4(new ra_msg4_t);
  uint8_t aes_gcm_iv[LC_AESGCM_IV_SIZE] = {0};
  lc_check(lc_rijndael128GCM_encrypt(&sp_db.sk_key,
                                     shared_key, LC_AESGCM_KEY_SIZE,
                                     &msg4->shared_key_ciphertext[0],
                                     &aes_gcm_iv[0], LC_AESGCM_IV_SIZE,
                                     nullptr, 0,
                                     &msg4->shared_key_mac));
  return msg4;
}
